# -*- coding: utf-8 -*-
"""HRP_Lineup_Creator

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X9q2cURBDbH1v4AHZCftUCOh84A3YWLH
"""

!pip install Unidecode
!pip install basketball-reference-scraper
!pip install PyPortfolioOpt
!pip install basketball_reference_web_scraper
!pip install selenium
!pip install kora -q
!pip install webdriver_manager
!pip install nba_api

import pypfopt
from basketball_reference_web_scraper import client
from basketball_reference_web_scraper.data import OutputType
import itertools
import basketball_reference_scraper as brs
import numpy as np
import pandas as pd
import json
import csv
from google.colab import files
import os

import requests

from datetime import date

import sklearn

import time
import matplotlib.pyplot as plt
import datetime

import nba_api
from itertools import combinations
from sklearn.preprocessing import MinMaxScaler
from basketball_reference_scraper.teams import get_roster

import warnings
warnings.simplefilter("ignore")

from basketball_reference_scraper.seasons import get_schedule, get_standings
from basketball_reference_scraper.box_scores import get_box_scores
from basketball_reference_scraper.players import get_stats, get_game_logs, get_player_headshot

from nba_api.stats.static import players
from google.colab import drive
drive.mount('drive')

abbr_dict={'atlanta hawks': 'ATL',
 'boston celtics': 'BOS',
 'brooklyn nets': 'BKN',
 'charlotte hornets': 'CHA',
 'chicago bulls': 'CHI',
 'cleveland cavaliers': 'CLE',
 'dallas mavericks': 'DAL',
 'denver nuggets': 'DEN',
 'detroit pistons': 'DET',
 'golden state warriors': 'GSW',
 'houston rockets': 'HOU',
 'indiana pacers': 'IND',
 'los angeles clippers': 'LAC',
 'los angeles lakers': 'LAL',
 'memphis grizzlies': 'MEM',
 'miami heat': 'MIA',
 'milwaukee bucks': 'MIL',
 'minnesota timberwolves': 'MIN',
 'new orleans pelicans': 'NOP',
 'new york knicks': 'NYK',
 'oklahoma city thunder': 'OKC',
 'orlando magic': 'ORL',
 'philadelphia 76ers': 'PHI',
 'phoenix suns': 'PHO',
 'portland trail blazers': 'POR',
 'sacramento kings': 'SAC',
 'san antonio spurs': 'SAS',
 'toronto raptors': 'TOR',
 'utah jazz': 'UTH',
 'washington wizards': 'WAS'}

cap_abbr_dict={x.upper():y for x,y in abbr_dict.items()}

abbr_cap_dict=dict((y,x) for x,y in cap_abbr_dict.items())

low2cap_dict={x:y.replace(' ','_') for x,y in zip(abbr_dict.keys(),cap_abbr_dict.keys())}

abbr_under_dict={x:y for x,y in zip(abbr_cap_dict.keys(),low2cap_dict.values())}

def Upload_DF(): #should only give ltgr, and price % of 52w High
  
  uploaded=files.upload()
  df_name=list(uploaded.keys())[0]

  row_lst=[]
  csv_file=open(df_name)
  reader=csv.reader(csv_file)
  for entry in reader:
    row_lst.append(entry)
  
  orig_df=pd.DataFrame(row_lst)

  return orig_df

def WMA(s, period):
       return s.rolling(period).apply(lambda x: ((np.arange(period)+1)*x).sum()/(np.arange(period)+1).sum(), raw=True)

def HMA(s, period):
       return WMA(WMA(s, period//2).multiply(2).sub(WMA(s, period)), int(np.sqrt(period)))

def Get_Injuries():

  url = 'https://www.rotowire.com/basketball/tables/injury-report.php?team=ALL&pos=ALL'
  jsonData = requests.get(url).json()

  injury_df = pd.DataFrame(jsonData)

  return injury_df

def Injury_Filter(dk_df):

  injury_df=Get_Injuries()

  dk_df.columns=dk_df.iloc[0,:]

  dk_df=dk_df.iloc[1:,:]

  dk_df.index=dk_df['Name']
  
  dk_df = dk_df[~dk_df.index.duplicated(keep='last')]

  injury_df=injury_df.sort_values(['status'])
  injury_df=injury_df[injury_df['status']!='Game Time Decision']


  available_players=set(dk_df['Name'])-set(injury_df['player'])

  dk_df=dk_df.loc[list(available_players)]

  for player in injury_df['player']:
    if dk_df['Name'].str.contains(player).any():
      dk_df=dk_df.drop(dk_df[dk_df['Name'].str.contains(player)].index)

  appg=[float(i) for i in dk_df['AvgPointsPerGame']]

  dk_df['AvgPointsPerGame']=appg
  dk_df=dk_df[dk_df['AvgPointsPerGame']>=15]

  game_info=[i[:7] for i in dk_df['Game Info'].unique()] 
  game_abbr=[i[:7] for i in dk_df['Game Info']]
  dk_df['Game Info']=game_abbr

  active_dict=players.get_active_players()

  active_list=[player['full_name'] for player in active_dict]

  dk_df=dk_df.loc[set(active_list).intersection(set(dk_df['Name']))]

  return dk_df,active_dict

def Extract_Stats(active_list):

  fp_list=[]
  fp_df=pd.DataFrame()

  for name in active_list:#dk_df.index:
    try:
      stats=get_stats(name+' III')
      fp_series=multi_fp_convert(stats,name)
      fp_list.append(fp_series)
    
    except Exception as e:
      print(e)
      try:
        fp_series=alt_stats(name)
        fp_list.append(fp_series)
      
      except Exception as e:
        print(e)
        pass
        
  fp_df=pd.concat(fp_list,axis=1)

  fp_df.to_csv('drive/My Drive/bball_stats.csv')

  return fp_df

def Get_FP_DF():
  fp_df=pd.read_csv('drive/My Drive/bball_stats.csv').sort_index()
  
  fp_df.index=fp_df[fp_df.columns[0]]

  fp_df=fp_df.iloc[:,1:]

  fp_df.index.name='SEASON'

  fp_df=(HMA(fp_df,2).fillna(fp_df)+fp_df)/2

  return fp_df.sort_index()

def alt_stats(name):

  current_year=datetime.datetime.now().year

  player_info=client.search(name)

  player_id=player_info['players'][0]['identifier']

  stat_series=pd.Series()

  for date in range(current_year-7,current_year):

    str_year=str(date)+'-'+str(date+1)[-2:]

    season_totals=client.players_season_totals(date+1)

    stats_df=pd.DataFrame(season_totals)

    try:
    
      player_box_scores=client.regular_season_player_box_scores(player_id,date+1)

      single_stats=stats_df[stats_df['slug']==player_id]

      if len(single_stats)>1:
        single_stats=pd.DataFrame(single_stats._get_numeric_data().mean()/len(player_box_scores)).T
      
      else:
        single_stats=single_stats._get_numeric_data()/len(player_box_scores)


      single_stats=single_stats.drop(['age', 'games_played', 'games_started', 'minutes_played',
          'made_field_goals', 'attempted_field_goals','attempted_three_point_field_goals',
          'made_free_throws', 'attempted_free_throws','personal_fouls'],axis=1)

      single_stats.columns=['3P','ORB','DRB','AST','STL','BLK','TOV','PTS']

      stat_series.loc[str_year]=multi_fp_convert(single_stats,name).item()

      stat_series.name=name
    
    except Exception as e:
     print(e)
     pass

  return stat_series

def multi_fp_convert(df,name):

  df=df[pd.to_numeric(df['PTS'], errors='coerce').notnull()]

  if 'SEASON' in df.columns:  
    seasons=df['SEASON']
    df.index=seasons

  relevant=['PTS','3P','ORB','DRB','AST','STL','BLK','TOV']

  to_drop=[col for col in df.columns if col not in relevant]
  df=df.drop(to_drop,axis=1)

  df=df.astype(float)

  df['RB']=df['DRB']+df['ORB']

  df[name]=df['PTS']+(df['3P']/2)+ 1.25*(df['RB'])+1.5*(df['AST'])+2*df['STL']+2*df['BLK']-(df['TOV']/2)

  categories=['PTS','RB','AST','STL','BLK']

  df['counter']=(df[categories]>=9.5).T.sum()

  df[name][df['counter']==2]+=1.5
  df[name][df['counter']>=3]+=3

  return df[name].groupby(df.index).mean()

def fp_convert(df):

  fp=df['PTS']+(df['3P']/2)+ 1.25*(df['RB'])+1.5*(df['AST'])+2*df['STL']+2*df['BLK']-(df['TOV']/2)/(0.8*df['MP'])

  categories=['PTS','RB','AST','STL','BLK']

  counter=0
  for i in categories:
    if df[i]>=10:
      counter+=1
  
  if counter==2:
    fp+=1.5
  
  elif counter>=3:
    fp+=3
  
  return fp

def Player2Team(end_year):

  players_stats=client.players_season_totals(end_year)

  season_stats=pd.concat([pd.DataFrame(player_stat) for player_stat in players_stats])

  player_team_dict={}

  for name in dk_df['Name']:
    relevant=season_stats[season_stats['name']==name]

    team_list=[cap_abbr_dict[team.value] for team in relevant['team']]
      
    player_team_dict[name]=team_list

  missing=set(dk_df['Name'])-set(season_stats['name'])

  for name in missing:

    try:

      true_name=client.search(name)['players'][0]['name']

      team_list=[cap_abbr_dict[team.value] for team in relevant['team']]

      player_team_dict[name]=team_list
    
    except Exception as e:
      print(e)
      
      stats=get_stats(name)

      relevance=stats['TEAM'][stats['SEASON']==season]

      team_list=[team for team in relevance]
      
      player_team_dict[name]=team_list

  return player_team_dict

def Get_Relevant_Players(fp_df,name_lst):

  correction=False
  for player in name_lst:
    if player not in fp_df.columns:
      correction=True

      to_split=player.split(' ')
      name=to_split[0]+' '+to_split[1]
      
      fp_series=alt_stats(name)

      fp_df[player]=fp_series
  
  if correction:
    fp_df.to_csv('drive/My Drive/bball_stats.csv')
    
  return fp_df[name_lst]

def Classic_Combinator(dk_df):
  p_df=dk_df['Salary'].astype(float)
  combo_list=[]

  for player in combinations(p_df.keys(),1): #n_players=1
    
    player_sum=p_df[list(player)].sum()
    player_list=list(player)

    for guards in combinations(dk_df['Salary'].drop(player_list)[dk_df['Position'].str.contains('G')].astype(float).keys(),3): #n_players=4
    
      guards_sum=p_df[list(guards)].sum()+player_sum
      guards_list=player_list+list(guards)

      for forwards in combinations(dk_df['Salary'].drop(guards_list)[dk_df['Position'].str.contains('F')].astype(float).keys(),3): #n_players=7
        
        forwards_sum=p_df[list(forwards)].sum()+guards_sum
        forwards_list=guards_list+list(forwards)

        if forwards_sum>50000:
          continue
    
        for center in combinations(dk_df['Salary'].drop(forwards_list)[dk_df['Position'].str.contains('C')].astype(float).keys(),1): #n_players=8
          
          center_sum=p_df[list(center)].sum()+forwards_sum
          center_list=forwards_list+list(center)

          if (center_sum<=50000) and (set(center_list) not in combo_list):
          
            combo_list.append(set(center_list))
          
          else:
            continue
  
  return combo_list

def Showdown_Combinator(dk_df):
  p_df=dk_df['Salary'].astype(float)
  combo_list=[]

  for captain in combinations(p_df.keys(),1): #n_players=1
    
    captain_sum=p_df[list(captain)].sum()*1.5
    
    captain_list=list(captain)

    for players in combinations(dk_df['Salary'].drop(captain_list).astype(float).keys(),5): #n_players=6
    
      players_sum=p_df[list(players)].sum()+captain_sum
      players_list=captain_list+list(players)

      if (players_sum<=50000) and (set(players_list) not in combo_list):
      
        combo_list.append(set(players_list))
      
      else:
        continue

  return combo_list

def Tiers_Combinator(dk_df):
  combo_list=[]

  for t1 in dk_df['Name'][dk_df['Roster Position'].str.contains('T1')].index:
    t1_list=[t1]

    for t2 in dk_df['Name'][dk_df['Roster Position'].str.contains('T2')].index:
      t2_list=t1_list+[t2]
      
      for t3 in dk_df['Name'][dk_df['Roster Position'].str.contains('T3')].index:
        t3_list=t2_list+[t3]

        for t4 in dk_df['Name'][dk_df['Roster Position'].str.contains('T4')].index:
          t4_list=t3_list+[t4]

          for t5 in dk_df['Name'][dk_df['Roster Position'].str.contains('T5')].index:
            t5_list=t4_list+[t5]

            for t6 in dk_df['Name'][dk_df['Roster Position'].str.contains('T6')].index:
              t6_list=t5_list+[t6]
    
              if set(t6_list) not in combo_list:
                combo_list.append(set(t6_list))

  return combo_list

def HRP(relevant_df):

  risk_model=pypfopt.risk_models.CovarianceShrinkage(relevant_df)
  cov_matrix=risk_model.oracle_approximating()

  hrp=pypfopt.hierarchical_portfolio.HRPOpt(cov_matrix=cov_matrix)
  
  weights=dict(hrp.optimize())
  hrp_series=pd.Series(weights)

  hrp_series.name='hrp_weights'

  return hrp_series

def Compare(hrp_weights,dk_df):

  combo_df=pd.concat([np.log(hrp_weights),np.sqrt(np.sqrt(dk_df['Salary'].astype(float)))],axis=1)

  #combo_df=(pd.concat([hrp_weights,dk_df['Salary'].astype(float)],axis=1))

  scaler=MinMaxScaler()

  combo_values=scaler.fit_transform(combo_df)

  combos=pd.DataFrame(combo_values,columns=combo_df.columns,index=combo_df.index)

  combos['diff']=abs(combos['hrp_weights']-combos['Salary'].astype(float))

  combos['diff']=np.sqrt(combos['diff'])

  scaler=MinMaxScaler()

  combos=pd.DataFrame(scaler.fit_transform(combos),index=combos.index,columns=combos.columns)

  return combos

def Execute(combo_list,fp_df,dk_df):

  if 'Salary' not in dk_df.columns:
    dk_df['Salary']=dk_df['AvgPointsPerGame']

  combination_series=pd.Series()

  fp_df=fp_df.replace({0:np.nan}).dropna(how='all')

  hrp_serie=HRP(fp_df[dk_df['Name']])

  for combo in combo_list:
    try:

      #relevant_df=Get_Relevant_Players(fp_df,combo)

      hrp_series=hrp_serie[combo]
      hrp_series=hrp_series[hrp_series!=0]

      combos=Compare(hrp_series,dk_df)

      c=2
    
      d=1-c/10

      selected=combos 
      
      combination_series.loc[str(combo)+str(c/10)]=((selected['diff']*(c/10))-(2*(c/10)*d*selected['Salary'])-(d)*selected['hrp_weights']).sum()
    
    except Exception as e:
      print(e)
      print(combo)
      pass

  print(combination_series.sort_values())
    
  return combination_series

def Execute1(combo_list,fp_df,dk_df):

  if 'Salary' not in dk_df.columns:
    dk_df['Salary']=dk_df['AvgPointsPerGame']

  combination_series=pd.Series()

  fp_df=fp_df.replace({0:np.nan}).dropna(how='all')

  for combo in combo_list:
    try:

      #relevant_df=Get_Relevant_Players(fp_df,combo)
      hrp_series=HRP(fp_df[combo])
      hrp_series=hrp_series[hrp_series!=0]

      combos=Compare(hrp_series,dk_df)

      c=2
      d=1-c/10

      selected=combos 
      
      combination_series.loc[str(combo)+str(c/10)]=((selected['diff']*(c/10))-(2*(c/10)*d*selected['hrp_weights'])-(d)*selected['Salary']).sum()
    
    except Exception as e:
      print(e)
      print(combo)
      pass
    
  print(combination_series.sort_values())
    
  return combination_series

def Player_Points():

  contest_df=Upload_DF()

  contest_df.columns=contest_df.iloc[0,:]

  contest_df=contest_df.iloc[1:,:]

  pd.DataFrame(contest_df['FPTS'],index=contest_df['Player'])

  player_points=contest_df[['Player','FPTS']].dropna()

  player_points.index=player_points['Player']

  player_points=player_points.drop(['Player'],axis=1).astype(float)

  return player_points

#three_df,ast_df,stl_df,blk_df,pts_df,fg_df,ft_df,rb_df,pos_dict=Extract_H2H(active_list)

dk_df=Upload_DF()
dk_df,active_dict=Injury_Filter(dk_df)

fp_df=Get_FP_DF()

#if current_season has at least 30 games, then use it 

#else use last season:

  #if current players are on different teams last season:
    #avoid using games where they are opponents

#backtest_length=3 years

#for player in team,
 #if player within backtest_length has been on a different team and team 1:
  #add player to group1
 #elif player on different team and on team 2:
  #add player to group2

#for i in year:

def Blacklitter(hrp_series,prices_df):
  risk_model=pypfopt.risk_models.CovarianceShrinkage(prices_df)
  cov_matrix=risk_model.oracle_approximating()
 
  view_series=hrp_series
 
  #cov_matrix=pypfopt.risk_models.fix_nonpositive_semidefinite(cov_matrix,fix_method='spectral')
 
  #if np.linalg.det(cov_matrix)==0:
    #cov_matrix=cov_matrix+0.0000001
  
  bl=pypfopt.black_litterman.BlackLittermanModel(cov_matrix=cov_matrix,absolute_views=view_series)
 
  weights=bl.bl_weights()
  weights=bl.clean_weights(cutoff=0.000001,rounding=8)
 
  return pd.Series(dict(weights))

def cluster_players(year,team1,team2):

  if team1=='CHA':
    player_list1=list(get_roster('CHO',year)['PLAYER'])
    player_list2=list(get_roster(team2,year)['PLAYER'])
  
  elif team2=='CHA':
    player_list1=list(get_roster(team1,year)['PLAYER'])
    player_list2=list(get_roster('CHO',year)['PLAYER'])

  else:

    player_list1=list(get_roster(team1,year)['PLAYER'])

    player_list2=list(get_roster(team2,year)['PLAYER'])

  common1=set(dk_df['Name'][dk_df['TeamAbbrev']==team1]).intersection(set(player_list1))

  common2=set(dk_df['Name'][dk_df['TeamAbbrev']==team2]).intersection(set(player_list2))
    
  different1=set(dk_df['Name'][dk_df['TeamAbbrev']==team1])-set(player_list1)

  different2=set(dk_df['Name'][dk_df['TeamAbbrev']==team2])-set(player_list2)

  opp1=different1.intersection(set(player_list2))

  opp2=different2.intersection(set(player_list1))

  return common1,common2,different1,different2,opp1,opp2


def scheduler(year,team1,team2):
  season=str(year)+'-'+str(year+1)[-2:]

  reg_season=get_schedule(year+1)

  playoffs=get_schedule(year+1,playoffs=True)

  schedule=pd.concat([reg_season,playoffs])

  schedule['VISITOR']=[i.lower() for i in schedule['VISITOR']]  

  schedule['HOME']=[i.lower() for i in schedule['HOME']]

  schedule['VISITOR']=[abbr_dict[i] for i in schedule['VISITOR']]

  schedule['HOME']=[abbr_dict[i] for i in schedule['HOME']]

  relevant=schedule[((schedule['VISITOR']==team1) & (schedule['HOME']==team2)) | ((schedule['VISITOR']==team2) & (schedule['HOME']==team1))]

  return relevant

def get_matchup(name,opp_team):

  try:
    info=client.search(name)

    id=info['players'][0]['identifier']
  
  except:
    info=client.search(name[:10])

    id=info['players'][0]['identifier']
    pass

  scores=client.regular_season_player_box_scores(player_identifier=id,season_end_year=2021)

  df=pd.DataFrame()

  for i in scores:
  
    if opp_team in str(i['opponent']):
      df=pd.concat([df,pd.Series(i)],axis=1)
  
  if len(df)>0:

    df=df.T.drop(['team','location','opponent','outcome','active','date'],axis=1)

  #df.columns=[i[:10] for i in df.columns]

  return df

def fix_matchup_df(df):
  
  to_drop=['made_field_goals','attempted_field_goals','attempted_three_point_field_goals','made_free_throws','attempted_free_throws','personal_fouls','game_score','plus_minus']

  df=df.drop(to_drop,axis=1)

  df['MP']=df['seconds_played']/60

  df['RB']=df['offensive_rebounds']+df['defensive_rebounds']

  df=df.drop(['seconds_played','offensive_rebounds','defensive_rebounds'],axis=1)

  df.columns=['3P','AST','STL','BLK','TOV','PTS','MP','RB']

  return df

def fp_convert(df):

  fp=df['PTS']+(df['3P']/2)+ 1.25*(df['RB'])+1.5*(df['AST'])+2*df['STL']+2*df['BLK']-(df['TOV']/2)/(0.8*df['MP'])

  categories=['PTS','RB','AST','STL','BLK']

  counter=0
  for i in categories:
    if df[i]>=10:
      counter+=1
  
  if counter==2:
    fp+=1.5
  
  elif counter>=3:
    fp+=3
  
  return fp

def InterPlayers(dk_df):

  teams=dk_df['TeamAbbrev'].unique()

  team1=teams[0]

  team2=teams[-1]


  current_year=datetime.datetime.now().year

  common1,common2,different1,different2,opp1,opp2=cluster_players(current_year,team1,team2)

  match_dict={}
  for player in list(common1)+list(common2)+list(different1)+list(different2):
    if player in common1 or player in different1:
      match_dict[player]=team2
    elif player in common2 or player in different2:
      match_dict[player]=team1
    
  lst=[]
  for player in match_dict:
    df=get_matchup(player,abbr_under_dict[match_dict[player]])

    if len(df)>0:
      df=fix_matchup_df(df)

      player_series=pd.Series(name=player)

      for idx,row in enumerate(df.iterrows()):
        player_series.loc[idx]=(fp_convert(row[-1]))
      
      lst.append(player_series)

  ts=pd.concat(lst,axis=1)

  combo_list=Showdown_Combinator(dk_df.loc[ts.columns])

  combination_series=pd.Series()

  hrp_series=HRP(ts)
 # bl_series=Blacklitter(hrp_series,ts)
  #bl_series.name='hrp_weights'

  for combo in combo_list:

    #hrp_series=HRP(ts[list(combo)])
    bl_series=Blacklitter(hrp_series,ts)
    bl_series.name='hrp_weights'
    
    combos=Compare(bl_series[bl_series!=0][combo],dk_df) #hrp_series

    selected=combos 

    c=1

    #for c in range(1,10):
    d=1-c/10

  
    #combination_series.loc[str(combo)+str(c/10)]=((selected['diff']*(c/10))-(2*(c/10)*d*selected['hrp_weights'])-(d)*selected['Salary']).sum()
    #combination_series.loc[str(combo)+str(c/10)]=((selected['diff']*(c/10))-(d)*selected['Salary']).sum()
    combination_series.loc[str(combo)]=((selected['diff'])-(selected['Salary'])).sum()

  return combination_series.sort_values()

#combo_list=Showdown_Combinator(dk_df)
#combo_list=Classic_Combinator(dk_df)
combo_list=Tiers_Combinator(dk_df)

df=Get_Injuries()

comb_series=InterPlayers(dk_df)
print(comb_series)